from flask import Flask, render_template, request, jsonify, send_file, send_from_directory
import requests
import json
import os
import base64
from github import Github
import re
from github import GithubException
from flask_socketio import SocketIO
from engineio.async_drivers import gevent
import argparse
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading
import tempfile
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
import socket

app = Flask(__name__, 
    template_folder=os.path.abspath(os.path.join(os.path.dirname(__file__), 'templates')),
    static_folder=os.path.abspath(os.path.join(os.path.dirname(__file__), 'static'))
)

socketio = SocketIO(app)

def safe_get(func):
    try:
        result = func()
        if isinstance(result, requests.Response):
            if result.status_code == 200:
                return result.json()
            else:
                print(f"Request failed with status code {result.status_code}")
                return []
        return result
    except Exception as e:
        print(f"Error: {str(e)}")
        return []

def get_repo_info(repo):
    return safe_get(lambda: repo.raw_data)

def get_repo_webhooks(repo):
    try:
        return {'repo': repo.name, 'hooks': [hook.raw_data for hook in repo.get_hooks()]}
    except:
        return {'repo': repo.name, 'hooks': []}

def get_github_info(token):
    g = Github(token)
    user = g.get_user()
    headers = {'Authorization': f'token {token}'}
    base_url = 'https://api.github.com'

    info = {}
    total_steps = 11
    current_step = 0

    def update_progress(step_name, sub_progress=None, sub_step=None):
        nonlocal current_step
        if sub_progress is None:
            current_step += 1
            progress = int((current_step / total_steps) * 100)
        else:
            progress = int(((current_step - 1 + sub_progress) / total_steps) * 100)
        socketio.emit('progress_update', {'progress': progress, 'step': step_name, 'sub_step': sub_step})
        socketio.sleep(0)

    update_progress("Rate Limit")
    rate_limit = g.get_rate_limit()
    info['rate_limit'] = {
        'core': {
            'limit': rate_limit.core.limit,
            'used': rate_limit.core.used,
            'remaining': rate_limit.core.remaining,
            'reset': rate_limit.core.reset.timestamp()
        }
    }

    update_progress("User Info")
    info['user_info'] = safe_get(lambda: user.raw_data)

    update_progress("Repositories")
    repos = list(user.get_repos())
    info['repos'] = []
    repo_count = len(repos)

    with ThreadPoolExecutor(max_workers=10) as executor:
        future_to_repo = {executor.submit(get_repo_info, repo): repo for repo in repos}
        for i, future in enumerate(as_completed(future_to_repo)):
            repo = future_to_repo[future]
            try:
                data = future.result()
                info['repos'].append(data)
            except Exception as exc:
                print(f'{repo.name} generated an exception: {exc}')
            update_progress("Repositories", (i + 1) / repo_count, repo.name)

    update_progress("Webhooks")
    info['webhooks'] = []
    webhook_count = len(repos)

    with ThreadPoolExecutor(max_workers=10) as executor:
        future_to_webhook = {executor.submit(get_repo_webhooks, repo): repo for repo in repos}
        for i, future in enumerate(as_completed(future_to_webhook)):
            repo = future_to_webhook[future]
            try:
                data = future.result()
                if data['hooks']:
                    info['webhooks'].append(data)
            except Exception as exc:
                print(f'{repo.name} webhooks generated an exception: {exc}')
            update_progress("Webhooks", (i + 1) / webhook_count, repo.name)

    update_progress("Organizations")
    info['orgs'] = safe_get(lambda: [org.raw_data for org in user.get_orgs()])

    update_progress("Gists")
    info['gists'] = safe_get(lambda: requests.get(f'{base_url}/gists', headers=headers))

    update_progress("SSH Keys")
    info['ssh_keys'] = safe_get(lambda: requests.get(f'{base_url}/user/keys', headers=headers))

    update_progress("Emails")
    info['emails'] = safe_get(lambda: user.get_emails())

    update_progress("Followers")
    info['followers'] = safe_get(lambda: [follower.login for follower in user.get_followers()])

    update_progress("Following")
    info['following'] = safe_get(lambda: [following.login for following in user.get_following()])

    update_progress("Permissions")
    info['permissions'] = safe_get(lambda: get_token_permissions(token))

    return info

def get_token_permissions(token):
    headers = {'Authorization': f'token {token}'}
    response = requests.get('https://api.github.com/user', headers=headers)
    return response.headers.get('X-OAuth-Scopes', '').split(', ')

def get_webhooks(g):
    webhooks = []
    for repo in g.get_user().get_repos():
        try:
            repo_hooks = repo.get_hooks()
            webhooks.extend([{'repo': repo.name, 'hook': hook.raw_data} for hook in repo_hooks])
        except GithubException:
            pass
    return webhooks

@app.route('/')
def index():
    return render_template('index.html')

@socketio.on('analyze_token')
def analyze_token(data):
    token = data['token']
    info = get_github_info(token)
    socketio.emit('analysis_complete', info)

@app.route('/export_pdf', methods=['POST'])
def export_pdf():
    data = request.json
    token = data.get('token', 'N/A')

    def create_table(data, headers, colWidths=None):
        table_style = TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 8),
            ('TOPPADDING', (0, 1), (-1, -1), 6),
            ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ])

        # Create a ParagraphStyle for wrapping text
        para_style = ParagraphStyle('BodyText', fontSize=8, leading=10)

        # Wrap all data in Paragraphs for automatic text wrapping
        wrapped_data = [[Paragraph(str(cell), para_style) for cell in row] for row in data]

        t = Table([headers] + wrapped_data, colWidths=colWidths, repeatRows=1)
        t.setStyle(table_style)
        return t

    with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as temp_file:
        pdf_output = temp_file.name
        doc = SimpleDocTemplate(pdf_output, pagesize=letter, rightMargin=72, leftMargin=72, topMargin=72, bottomMargin=18)
        
        styles = getSampleStyleSheet()
        styles.add(ParagraphStyle(name='CustomNormal', fontSize=10, spaceAfter=6))

        Story = []
        
        # Title and Token
        Story.append(Paragraph("GitHub Account Information", styles['Heading1']))
        Story.append(Paragraph(f"Token: {token[:10]}...{token[-5:]}", styles['CustomNormal']))
        Story.append(Spacer(1, 0.2*inch))

        # User Info
        user_info = data['user_info']
        user_info_data = [
            ['Username', user_info.get('login', 'N/A')],
            ['Name', user_info.get('name', 'N/A')],
            ['Email', user_info.get('email', 'N/A')],
            ['Location', user_info.get('location', 'N/A')],
            ['Public Repos', str(user_info.get('public_repos', 0))],
            ['Private Repos', str(user_info.get('total_private_repos', 0))]  # Chang√© 'N/A' en 0
        ]
        Story.append(Paragraph("User Info", styles['Heading2']))
        t = Table(user_info_data)
        t.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, -1), colors.beige),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        Story.append(t)
        Story.append(Spacer(1, 0.2*inch))

        # Quick Stats
        Story.append(Paragraph("Quick Stats", styles['Heading2']))
        quick_stats = [
            f"Repositories: {len(data['repos'])}",
            f"Organizations: {len(data['orgs'])}",
            f"Followers: {len(data['followers'])}",
            f"Following: {len(data['following'])}",
            f"Gists: {len(data['gists'])}",
        ]
        for stat in quick_stats:
            Story.append(Paragraph(stat, styles['CustomNormal']))
        
        Story.append(PageBreak())

        # Detailed Sections
        sections = [
            ('Repositories', 'repos', ['Name', 'Description', 'Private'], [1.5*inch, 4*inch, 0.7*inch]),
            ('Organizations', 'orgs', ['Login', 'Description'], [2*inch, 4.5*inch]),
            ('Gists', 'gists', ['ID', 'Description'], [2*inch, 4.5*inch]),
            ('SSH Keys', 'ssh_keys', ['ID', 'Key'], [1*inch, 5.5*inch]),
            ('Emails', 'emails', ['Email', 'Primary', 'Verified'], [3*inch, 1*inch, 1*inch]),
            ('Followers', 'followers', ['Username'], None),
            ('Following', 'following', ['Username'], None),
            ('Permissions', 'permissions', ['Permission'], None),
            ('Webhooks', 'webhooks', ['Repository', 'URL', 'Events'], [2*inch, 3*inch, 1.5*inch]),
        ]

        for title, key, headers, colWidths in sections:
            Story.append(Paragraph(title, styles['Heading2']))
            
            if key == 'repos':
                table_data = [[repo['name'], repo.get('description', 'N/A'), 'Yes' if repo['private'] else 'No'] for repo in data[key]]
            elif key == 'orgs':
                table_data = [[org['login'], org.get('description', 'N/A')] for org in data[key]]
            elif key == 'gists':
                table_data = [[gist['id'], list(gist['files'].values())[0]['filename']] for gist in data[key]]
            elif key == 'ssh_keys':
                table_data = [[str(key['id']), key['key']] for key in data[key]]
            elif key == 'emails':
                table_data = [[email['email'], 'Yes' if email['primary'] else 'No', 'Yes' if email['verified'] else 'No'] for email in data[key]]
            elif key in ['followers', 'following']:
                table_data = [[user] for user in data[key]]
            elif key == 'permissions':
                table_data = [[perm] for perm in data[key]]
            elif key == 'webhooks':
                table_data = [[hook['repo'], hook['hooks'][0]['config']['url'], ', '.join(hook['hooks'][0]['events'])] for hook in data[key] if hook['hooks']]
            
            t = create_table(table_data, headers, colWidths)
            Story.append(t)
            Story.append(Spacer(1, 0.2*inch))
            Story.append(PageBreak())

        doc.build(Story)

    return send_file(pdf_output, as_attachment=True, download_name="github_info.pdf")

@app.route('/favicon.ico')
def favicon():
    return send_from_directory(os.path.join(app.root_path, 'static'),
                               'favicon.ico', mimetype='image/vnd.microsoft.icon')

def main():
    parser = argparse.ArgumentParser(description="Token Exploiter")
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug mode")
    parser.add_argument("-l", "--listen", default="127.0.0.1:5000", help="Host and port to listen on (default: 127.0.0.1:5000)")
    args = parser.parse_args()

    host, port = args.listen.split(':')
    port = int(port)

    if args.debug:
        app.debug = True
        print(f"Debug mode: http://{host}:{port}")
        socketio.run(app, host=host, port=port, debug=True)
    else:
        url = f"http://{host}:{port}"
        print(f"Token Exploiter is running at: {host}:{port}")
        print(f"Click here to open: \033[94m{url}\033[0m")
        socketio.run(app, host=host, port=port)

if __name__ == '__main__':
    main()